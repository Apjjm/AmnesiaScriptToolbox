#ifndef LIB_VECTOR3_LHPS
#define LIB_VECTOR3_LHPS
#include "../ISave.lhps"
#include "../IStringConversion.lhps"


class Vec3 : ILocalSave, IGlobalSave, IStringConversion {

	float x;
	float y;
	float z;
	
	
	Vec3() {
		x = 0.0f;
		y = 0.0f;
		z = 0.0f;
	}
		
	Vec3(float vecx, float vecy, float vecz) {
		x = vecx;
		y = vecy;
		z = vecz;
	}
	
	Vec3(float[] vector) {
		x = vector[0];
		y = vector[1];
		z = vector[2];
	}
	
	Vec3(const Vec3 &in vector) {
		x = vector.x;
		y = vector.y;
		z = vector.z;
	}
	
	//////////////////////////////////////////////////
	// To/From string / saves
	//////////////////////////////////////////////////
	void saveLocal(const string& in id) const {
		SetLocalVarFloat(id + "_{VEC3_X}",x);
		SetLocalVarFloat(id + "_{VEC3_Y}",y);
		SetLocalVarFloat(id + "_{VEC3_Z}",z);
	}
	
	void loadLocal(const string& in id) {
		x = GetLocalVarFloat(id + "_{VEC3_X}");
		y = GetLocalVarFloat(id + "_{VEC3_Y}");
		z = GetLocalVarFloat(id + "_{VEC3_Z}");
	}
	
	void saveGlobal(const string& in id) const {
		SetGlobalVarFloat(id + "{VEC3_X}",x);
		SetGlobalVarFloat(id + "{VEC3_Y}",y);
		SetGlobalVarFloat(id + "{VEC3_Z}",z);
	}
	
	void loadGlobal(const string& in id) {
		x = GetGlobalVarFloat(id + "_{VEC3_X}");
		y = GetGlobalVarFloat(id + "_{VEC3_Y}");
		z = GetGlobalVarFloat(id + "_{VEC3_Z}");
	}
	
	string toString() const {
		return "(" + x + "," + y + "," + z + ")";
	}
	
	void fromString(const string& in asString) {
		AddDebugMessage("Vec3::fromString() not implemented yet",false);
		/* Todo: Wait to confirm number parsing in script update instead of rolling own */
	}
	
	//////////////////////////////////////////////////
	// Vector arithmetic
	//////////////////////////////////////////////////
	float dot(const Vec3& in vector) const {
		return x * vector.x + y * vector.y + z * vector.z;
	}
	
	float dot(const float[]& in vector) const {
		return x * vector[0] + y * vector[1] + z * vector[2];
	}
	
	Vec3 cross(const Vec3& in vector) const {
		return Vec3( y*vector.z - vector.y*z,
		             z*vector.x - vector.z*x,
					 x*vector.y - vector.x*y );
	}
	
	Vec3 cross(const float[]& in vector) const {
		return Vec3( y*vector[2] - vector[1]*z,
		             z*vector[0] - vector[2]*x,
		             x*vector[1] - vector[0]*y );
	}
	
	float length() const {
		AddDebugMessage("Vec3::length() not implemented yet - returning length2()",false);
		/* Todo: Wait to confirm sqrt in script update instead of rolling own */
		return x*x + y*y + z*z;
	}
	
	float length2() const {
		return x*x + y*y + z*z;
	}
	
	Vec3 norm() const {
		float n = length();
		return (n>0.0f)?(Vec3(x/n,y/n,z/n)):(Vec3());
	}
	
	Vec3 normExt(float epsilon) const {
		Vec3 output = Vec3(x,y,z);
		float n = output.length();
		
		if(n < epsilon) return Vec3();
		
		while(n > (1.0f + epsilon) || n < (1.0f - epsilon) )
		{
			output = Vec3(output.x / n, output.y / n, output.z / n);
			n = output.length();
		}
	
		return output;
	}
	
	//////////////////////////////////////////////////
	// Operator overloads
	//////////////////////////////////////////////////
	// Equality operator
	bool opEquals(const Vec3& in rhs) const { 
		return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);
	}
   
	bool opEquals(const float[]& in rhs) const {
		if(rhs.length() != 3) 
			return false;
		else
			return (x == rhs[0]) && (y == rhs[1]) && (z == rhs[2]);
	}
   
	// Compound assignment operators
	void opAddAssign(const Vec3 &in rhs) { 
		x += rhs.x; 
		y += rhs.y;
		z += rhs.z; 
	}
	
	void opSubAssign(const Vec3 &in rhs) { 
		x -= rhs.x; 
		y -= rhs.y;
		z -= rhs.z; 
	}
	
	void opAddAssign(const float[] &in rhs) { 
		x += rhs[0]; 
		y += rhs[1];
		z += rhs[2]; 
	}
	
	void opSubAssign(const float[] &in rhs) { 
		x -= rhs[0]; 
		y -= rhs[1];
		z -= rhs[2]; 
	}
   
	// Math operators
	Vec3 opAdd(const Vec3 &in rhs) const { 
		return Vec3(x+rhs.x,y+rhs.y,z+rhs.z);
	}
	
	Vec3 opAdd(const float[] &in rhs) const { 
		return Vec3(x+rhs[0],y+rhs[1],z+rhs[2]);
	}

	Vec3 opAdd(const int n) const { 
		return Vec3(x+n,y+n,z+n); 
	}
   
	Vec3 opSub(const Vec3 &in rhs) const { 
		return Vec3(x-rhs.x,y-rhs.y,z-rhs.z);
	}
	
	Vec3 opSub(const float[] &in rhs) const { 
		return Vec3(x-rhs[0],y-rhs[1],z-rhs[2]);
	}

	Vec3 opSub(const int n) const { 
		return Vec3(x-n,y-n,z-n); 
	}
	   
	///Multiplication & Dot Product 
	float opMul(const Vec3 &in rhs) const { 
		return (x*rhs.x) + (y*rhs.y) + (z*rhs.z);
	}
	
	float opMul(const float[] &in rhs) const { 
		return (x*rhs[0]) + (y*rhs[1]) + (z*rhs[2]);
	}
	
	Vec3 opMul(const float n) const { 
		return Vec3(x*n,y*n,z*n); 
	}
	
	Vec3 opMul(const int n) const { 
		return Vec3(x*n,y*n,z*n);
	}
     
	//Cross product (^)
	Vec3 opXor(const Vec3 &in rhs) const { 
		return Vec3( y*rhs.z - rhs.y*z,
		             z*rhs.x - rhs.z*x,
		             x*rhs.y - rhs.x*y); 
	}

	Vec3 opXor(const float[] &in rhs) const { 
		return Vec3( y*rhs[2] - rhs[1]*z,
		             z*rhs[0] - rhs[2]*x,
		             x*rhs[1] - rhs[0]*y );
	}
	
	//Division
	Vec3 opDiv(const float n) const {
		return Vec3(x/n,y/n,z/n);
	}
	
	Vec3 opDiv(const int n) const {
		return Vec3(x/n,y/n,z/n);
	}
   	
	//Indexing
	float opIndex(uint index) const {
		switch(index)
		{
			case 0:
				return x;
			case 1:
				return y;
			case 2:
				return z;
		}
		return 0.0f;
	}
	
	void opIndex(uint index, float value) {
		switch(index)
		{
			case 0:
				x = value;
				return;
			case 1:
				y = value;
				return;
			case 2:
				z = value;
				return;
		}
	}
}

#endif