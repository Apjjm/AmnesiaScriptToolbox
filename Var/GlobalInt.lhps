#ifndef LIB_GLOBALINT_LHPS
#define LIB_GLOBALINT_LHPS

#include "../IStringConversion.lhps"
#include "../Math/fCompare.lhps"
#include "AmnesiaVar.lhps"

/**
 * Wrapper class for GlobalVarInt variables stored using the Amnesia script
 * functions. Behaves like a normal int using a standard operator set for
 * manipulating the data.
 *
 * Do not modify the global variable manually. This can cause unwanted
 * behavior since the value of the variables is cached to prevent repeated
 * calls to the Amnesia script functions.
 *
 * Assigning GlobalInt to primitives is not supported, since global operators
 * for Angelscript can only be implemented in native code (as far as I know).
 **/
class GlobalInt : IStringConversion, AmnesiaVar
{
    private int val; // Cache value

    // Store Amnesia var into a cache variable
    private void downloadValue()
    {
        val = GetGlobalVarInt(varName);
    }

    // Upload val in Amnesia variable
    private void uploadValue()
    {
        SetGlobalVarInt(varName, val);
    }

    /////////////////////////////////////
    // Public methods
    /////////////////////////////////////

    GlobalInt(string name)
    {
        setName(name);
        downloadValue();
    }

    string toString() const
    {
        return "GlobalInt \"" + varName + "\":" + val;
    }

    void fromString(const string& in asString)
    {
        /* Todo: Wait to confirm number parsing in script update instead of rolling own */
    }

    /////////////////////////////////////
    // == operator overloads
    /////////////////////////////////////

    // Equals another GlobalInt
    // Only checks the variable value, does not compare varName
    bool opEquals(const GlobalInt& in other) const
    {
        return val == other.val;
    }

    // Equals an int
    bool opEquals(int other) const
    {
        return val == other;
    }

    // Check varName equals string
    bool opEquals(const string& in other) const
    {
        return varName == other;
    }

    bool opEquals(float other) const
    {
        return fCompare(other, val);
    }

    /////////////////////////////////////
    // = operator overloads
    /////////////////////////////////////

    // Assign GlobalInt value
    GlobalInt@ opAssign(const GlobalInt& in other)
    {
        val = other.val;
        uploadValue();
        return this;
    }

    // Assign int value
    GlobalInt@ opAssign(int other)
    {
        val = other;
        uploadValue();
        return this;
    }

    // Assign a float value
    GlobalInt@ opAssign(float other)
    {
        val = int(other);
        uploadValue();
        return this;
    }

    /////////////////////////////////////
    // Binary operator overloads
    /////////////////////////////////////

    // string + GlobalInt
    // Return string other + val
    string opAdd_r(const string& in other) const
    {
        return other + val;
    }

    // += other GlobalInt
    GlobalInt@ opAddAssign(const GlobalInt& in other)
    {
        val += other.val;
        uploadValue();
        return this;
    }

    // += an int
    GlobalInt@ opAddAssign(int other)
    {
        val += other;
        uploadValue();
        return this;
    }

    // += a float
    GlobalInt@ opAddAssign(float other)
    {
        val += int(other);
        uploadValue();
        return this;
    }

    // int - GlobalInt
    int opSub_r(int other) const
    {
        return other - val;
    }

    // GlobalInt - GlobalInt
    int opSub(const GlobalInt& in other) const
    {
        return val - other.val;
    }

    // float - GlobalInt
    int opSub_r(float other) const
    {
        return int(other) - val;
    }

    // GlobalInt - float
    int opSub(float other) const
    {
        return val - int(other);
    }

    // -= other GlobalInt
    GlobalInt@ opSubAssign(const GlobalInt& in other)
    {
        val -= other.val;
        uploadValue();
        return this;
    }

    // -= an int
    GlobalInt@ opSubAssign(int other)
    {
        val -= other;
        uploadValue();
        return this;
    }

    // -= a float
    GlobalInt@ opSubAssign(float other)
    {
        val -= int(other);
        uploadValue();
        return this;
    }

    int opMul_r(int other) const
    {
        return other * val;
    }

    int opMul(int other) const
    {
        return val * other;
    }

    int opMul_r(float other) const
    {
        return int(other) * val;
    }

    int opMul(float other) const
    {
        return val * int(other);
    }

    int opMul(const GlobalInt& in other) const
    {
        return val * other.val;
    }

    GlobalInt@ opMulAssign(const GlobalInt& in other)
    {
        val *= other.val;
        uploadValue();
        return this;
    }

    GlobalInt@ opMulAssign(int other)
    {
        val *= other;
        uploadValue();
        return this;
    }

    GlobalInt@ opMulAssign(float other)
    {
        val *= int(other);
        uploadValue();
        return this;
    }

    int opNeg() const
    {
        return -val;
    }

    int opCom() const
    {
        return ~val;
    }

    int opPreInc()
    {
        ++val;
        uploadValue();
        return val;
    }

    int opPreDec()
    {
        --val;
        uploadValue();
        return val;
    }

    int opPostInc()
    {
        val++;
        uploadValue();
        return val;
    }

    int opPostDec()
    {
        val--;
        uploadValue();
        return val;
    }

    int opCmp(int other) const
    {
        if(val < other)
            return 1;
        else if(val > other)
            return -1;
        else
            return 0;
    }

    GlobalInt@ opModAssign(int other)
    {
        val %= other;
        uploadValue();
        return this;
    }

    GlobalInt@ opModAssign(const GlobalInt& other)
    {
        val %= other.val;
        uploadValue();
        return this;
    }

    GlobalInt@ opAndAssign(int other)
    {
        val &= other;
        uploadValue();
        return this;
    }

    GlobalInt@ opAndAssign(const GlobalInt& other)
    {
        val &= other.val;
        uploadValue();
        return this;
    }

    GlobalInt@ opOrAssign(int other)
    {
        val |= other;
        uploadValue();
        return this;
    }

    GlobalInt@ opOrAssign(const GlobalInt& other)
    {
        val |= other.val;
        uploadValue();
        return this;
    }

    GlobalInt@ opXorAssign(int other)
    {
        val ^= other;
        uploadValue();
        return this;
    }

    GlobalInt@ opXorAssign(const GlobalInt& other)
    {
        val ^= other.val;
        uploadValue();
        return this;
    }

    GlobalInt@ opShrAssign(int other)
    {
        val >>= other;
        uploadValue();
        return this;
    }

    GlobalInt@ opShrAssign(const GlobalInt& other)
    {
        val >>= other.val;
        uploadValue();
        return this;
    }

    GlobalInt@ opShlAssign(int other)
    {
        val <<= other;
        uploadValue();
        return this;
    }

    GlobalInt@ opShlAssign(const GlobalInt& other)
    {
        val <<= other.val;
        uploadValue();
        return this;
    }

    int opMod(int other) const
    {
        return val % other;
    }

    int opMod_r(int other) const
    {
        return other % val;
    }

    int opAnd(int other) const
    {
        return val & other;
    }

    int opAnd_r(int other) const
    {
        return other & val;
    }

    int opOr(int other) const
    {
        return val | other;
    }

    int opOr_r(int other) const
    {
        return other | val;
    }

    int opXor(int other) const
    {
        return val ^ other;
    }

    int opXor_r(int other) const
    {
        return other ^ val;
    }

    int opShr(int other) const
    {
        return val >> other;
    }

    int opShr_r(int other) const
    {
        return other >> val;
    }

    int opShl(int other) const
    {
        return val << other;
    }

    int opShl_r(int other) const
    {
        return other << val;
    }
}

class GlobalInt32 : GlobalInt
{
}

#endif // LIB_GLOBALINT_LHPS
